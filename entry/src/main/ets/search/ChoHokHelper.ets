import { relationalStore } from '@kit.ArkData';
import { BusinessError } from '@kit.BasicServicesKit';
import { ChoHokLexicon, ChoHokUnit } from './ChoHokUnit';

export class ChoHokHelper {
    static search(text: string, store: relationalStore.RdbStore): ChoHokLexicon[] {
        if (text.length > 0) {
            const codes = new Set<number>();
            for (let index = 0; index < text.length; index++) {
                const code = text.codePointAt(index);
                if (code) {
                    codes.add(code);
                }
            }
            const lexicons: ChoHokLexicon[] = [];
            codes.forEach(code => {
                const instance = ChoHokHelper.match(code, store);
                lexicons.push(instance);
            })
            return lexicons.filter(item => item.isNotEmpty);
        } else {
            return [];
        }
    }
    static match(code: number, store: relationalStore.RdbStore): ChoHokLexicon {
        const units: ChoHokUnit[] = [];
        const command: string = `SELECT * FROM chohoktable WHERE code = ${code};`;
        let res: relationalStore.ResultSet | undefined = undefined;
        try {
            res = store.querySqlSync(command);
            while (res.goToNextRow()) {
                // const code = res.getLong(0);
                const word = res.getString(1);
                const romanization = res.getString(2);
                const initial = res.getString(3);
                const final = res.getString(4);
                const tone = res.getString(5);
                const faancit = res.getString(6);
                const instance: ChoHokUnit = {
                    word: word,
                    romanization: romanization,
                    pronunciation: ChoHokHelper.pronunciationFrom(initial, final),
                    tone: tone,
                    faancit: (faancit + "åˆ‡"),
                    homophones: []
                };
                units.push(instance);
            }
        } catch (error) {
            let err: BusinessError = error as BusinessError;
            console.error(`message: ${err.message}, code: ${err.code}`);
        } finally {
            res?.close();
        }
        const word: string = (units.length > 0) ? units[0].word : "?";
        const adjustedUnits: ChoHokUnit[] = units.map((unit) => {
            const fetchedHomophones = ChoHokHelper.fetchHomophones(unit.romanization, store).filter(item => item !== word);
            const newInstance: ChoHokUnit = {
                word: unit.word,
                romanization: unit.romanization,
                pronunciation: unit.pronunciation,
                tone: unit.tone,
                faancit: unit.faancit,
                homophones: fetchedHomophones
            };
            return newInstance;
        })
        const lexicon: ChoHokLexicon = {
            isEmpty: adjustedUnits.length < 1,
            isNotEmpty: adjustedUnits.length > 0,
            word: word,
            units: adjustedUnits
        }
        return lexicon;
    }
    private static fetchHomophones(romanization: string, store: relationalStore.RdbStore): string[] {
        const homophones: string[] = [];
        const command: string = "SELECT word FROM chohoktable WHERE romanization = ? LIMIT 11;";
        let res: relationalStore.ResultSet | undefined = undefined;
        try {
            res = store.querySqlSync(command, [romanization]);
            while (res.goToNextRow()) {
                const word = res.getString(0);
                homophones.push(word);
            }
        } catch (error) {
            let err: BusinessError = error as BusinessError;
            console.error(`message: ${err.message}, code: ${err.code}`);
        } finally {
            res?.close();
        }
        return homophones;
    }
    private static pronunciationFrom(initial: string, final: string): string {
        const convertedInitial: string = (initial === "X") ? "" : initial;
        const convertedFinal: string = (final === "X") ? "" : final;
        return convertedInitial + convertedFinal;
    }
}
